# aws-lambda-decorators

A set of Python decorators to ease the development of AWS lambda functions.

## Installation

The easiest way to use these AWS Lambda Decorators is to install them through Pip:

`pip install -i https://test.pypi.org/simple/ aws-lambda-decorators`

## Package Contents

### Decorators

The current list of AWS Lambda Python Decorators includes:

* __extract__: a decorator to extract and validate specific keys of a dictionary parameter passed to a AWS Lambda function.
* __extract_from_event__: a facade of __extract__ to extract and validate keys from an AWS API Gateway lambda function _event_ parameter.
* __extract_from_context__: a facade of __extract__ to extract and validate keys from an AWS API Gateway lambda function _context_ parameter.
* __extract_from_ssm__: a decorator to extract from AWS SSM the values of a set of parameter keys.
* __validate__: a decorator to validate a list of function parameters.
* __log__: a decorator to log the parameters passed to the lambda function and/or the response of the lambda function.
* __handle_exceptions__: a decorator to handle any type of declared exception generated by the lambda function. 
* __response_body_as_json__: a decorator to transform the body of a response to json.

### Validators

Currently, the package offers 2 validators:

* __Mandatory__: Checks if a parameter has a not None value.
* __RegexValidator__: Checks a parameter against a regular expression.

### Decoders

The package offers functions to decode from JSON and JWT. 

* __decode_json__: decodes a string to json
* __decode_jwt__: decodes a string to a JWT

## Examples

### extract

This decorator extracts and validates values from dictionary parameters passed to a Lambda Function.

* The decorator takes a list of Parameter objects.
* Each Parameter object requires a non-empty path to the parameter in the dictionary, and the name of the dictionary (func_param_name)
* The parameter value is extracted and added as a kwarg to the lambda handler.
* You can add the parameter to the handler signature, or access it in the handler through kwargs.
* The name of the extracted parameter is defaulted to the last element of the path name, but can be changed by passing a (valid pythonic variable name) var_name
* You can define a default value for the parameter in the lambda handler itself.
* A 400 exception is raised when the parameter cannot be extracted or when it does not validate.
* A variable path (e.g. '/headers/Authorization[jwt]/sub') can be annotated to specify a decoding. In the example, Authorization might contain a JWT, which needs to be decoded before accessing the "sub" element.

```python
@extract(parameters=[
    Parameter(path='/parent/my_param', func_param_name='a_dictionary'),  # extracts a non mandatory my_param from a_dictionary
    Parameter(path='/parent/missing_non_mandatory', func_param_name='a_dictionary', default='I am missing'),  # extracts a non mandatory missing_non_mandatory from a_dictionary
    Parameter(path='/parent/missing_mandatory', func_param_name='a_dictionary'),  # does not fail as the parameter is not validated as mandatory
    Parameter(path='/parent/child/id', validators=[Mandatory], var_name='user_id', func_param_name='another_dictionary')  # extracts a mandatory id as "user_id" from another_dictionary
])
def lambda_handler(a_dictionary, another_dictionary, my_param='aDefaultValue', missing_non_mandatory='I am missing', missing_mandatory=None, user_id=None):
    """
        Given these two dictionaries:
        
        a_dictionary = { 
            'parent': { 
                'my_param': 'Hello!' 
            }, 
            'other': 'other value' 
        }
        
        another_dictionary = { 
            'parent': { 
                'child': { 
                    'id': '123' 
                } 
            } 
        }
    
        you can now access the extracted parameters directly: 
    """
    print(my_param)  # prints 'Hello!'
    print(missing_non_mandatory)  # prints 'I am missing'
    print(missing_mandatory)  # prints 'None'
    print(user_id)  # prints '123'
```

Or you can use kwargs instead of specific parameter names:

```python
@extract(parameters=[
    Parameter(path='/parent/my_param', func_param_name='a_dictionary'),  # extracts a non mandatory my_param from a_dictionary
])
def lambda_handler(a_dictionary, **kwargs):
    """
        a_dictionary = { 
            'parent': { 
                'my_param': 'Hello!' 
            }, 
            'other': 'other value' 
        }
    """
    print(kwargs['my_param'])  # prints 'Hello!'
```

A missing mandatory parameter, or a parameter that fails validation, will raise an exception:

```python
@extract(parameters=[
    Parameter(path='/parent/mandatory_param', func_param_name='a_dictionary', validators=[Mandatory]),  # extracts a mandatory mandatory_param from a_dictionary
])
def lambda_handler(a_dictionary, mandatory_param=None):
    print('Here!')  # this message will never be reached
    
response = lambda_handler({'parent': {'my_param': 'Hello!'}, 'other': 'other value'} )

print(response)  # prints { 'statusCode': 400, 'body': 'Error extracting parameters' } and logs a more detailed error

```

You can decode any part of the parameter path from json or any other existing annotation.

```python
@extract(parameters=[
    Parameter(path='/parent[json]/my_param', func_param_name='a_dictionary'),  # extracts a non mandatory my_param from a_dictionary
])
def lambda_handler(a_dictionary, my_param=None):
    """
        a_dictionary = { 
            'parent': '{"my_param": "Hello!" }', 
            'other': 'other value' 
        }
    """
    print(my_param)  # prints 'Hello!'

```

### extract_from_event

This decorator is just a facade to the extract method to be used in AWS Api Gateway Lambdas. It automatically extracts from the event lambda parameter.

```python
@extract_from_event(parameters=[
    Parameter(path='/body[json]/my_param', validators=[Mandatory]),  # extracts a mandatory my_param from the json body of the event
    Parameter(path='/headers/Authorization[jwt]/sub', validators=[Mandatory], var_name='user_id')  # extract the mandatory sub value as user_id from the authorization JWT
])
def api_gateway_lambda_handler(event, context, my_param=None, user_id=None):
    """
        event = { 
            'body': '{"my_param": "Hello!"}', 
            'headers': { 
                'Authorization': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c' 
            } 
        }
    """
    print(my_param)  # prints 'Hello!'
    print(user_id)  # prints '1234567890'
```

### extract_from_context

This decorator is just a facade to the extract method to be used in AWS Api Gateway Lambdas. It automatically extracts from the context lambda parameter.

```python
@extract_from_context(parameters=[
    Parameter(path='/parent/my_param', validators=[Mandatory]),  # extracts a mandatory my_param from the parent element in context
])
def api_gateway_lambda_handler(event, context, my_param=None):
    """
        context = {
            'parent': {
                'my_param': 'Hello!'
            }
        }
    """    
    print(my_param)  # prints 'Hello!'
```

### extract_from_ssm

This decorator extract a parameter from AWS SSM and passes the parameter down to your function as a kwarg.

* The decorator takes a list of SSMParameter objects.
* Each SSMParameter object requires the name of the SSM parameter (ssm_name)
* If no var_name is passed in, the extracted value is passed to the function with the ssm_name name

```python
@extract_from_ssm(ssm_parameters=[
    SSMParameter(ssm_name='one_key'),  # extracts the value of one_key from SSM as a kwarg named "one_key"
    SSMParameter(ssm_name='another_key', var_name="another"),  # extracts another_key as a kwarg named "another"
])
def your_function(your_func_params, one_key=None, another=None):
    pass
```

### validate

This decorator validates a list of non dictionary parameters from your lambda function.

* The decorator takes a list of Parameter objects.
* Each parameter object needs the name of the lambda function parameter that it is going to be validated, and the list of rules to validate.
* A 400 exception is raised when the parameter does not validate.

```python
@validate(parameters=[
    ValidatedParameter(func_param_name='a_param', validators=[Mandatory]),  # validates a_param as mandatory
    ValidatedParameter(func_param_name='another_param', validators=[Mandatory, RegexValidator(r'\d+')])  # validates another_param as mandatory and containing only digits
])
def your_function(a_param, another_param):
    print(a_param)  # prints 'Hello!'
    print(another_param)  # prints '123456'
    
your_function('Hello!', '123456')
```

Given the same function `your_function`, a 400 exception is returned/raised if at least one parameter does not validate:

```python
your_function('Hello!', 'ABCD')
```

### log

This decorator allows for logging the function arguments and/or the lambda response.

```python
@log(parameters=True, response=True)
def lambda_handler(parameters): 
    return 'Done!'
    
lambda_handler('Hello!')  # logs 'Hello!' and 'Done!'
```

### handle_exceptions

This decorator handles a list of exceptions, returning a 400 response containing the specified friendly message to the caller.

* The decorator takes a list of ExceptionHandler objects.
* Each ExceptionHandler requires the type of exception to check, and the friendly message to return to the caller.

```python
@handle_exceptions(handlers=[
    ExceptionHandler(ClientError, "Your message when a client error happens.")
])
def lambda_handler():
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table('non_existing_table')
    table.query(KeyConditionExpression=Key('user_id').eq(user_id))
    
lambda_handler()  # returns {'body': 'Your message when a client error happens.', 'statusCode': 400}
```

### response_body_as_json

This decorator ensures that, if the response contains a body, the body is dumped as json.

```python
@response_body_as_json
def lambda_handler():
    return { 'statusCode': 400, 'body': { 'param': 'hello!' } }
    
lambda_handler()  # returns { 'statusCode': 400, 'body': "{ 'param': 'hello!' }" }
```

### Writing your own Validators

### Writing your own Decoders

## Documentation

You can get the docstring help by running:  

```bash
>>> from aws_lambda_decorators import decorators
>>> help(decorators.extract)
```

## Contributing

If you want to contribute to this project, clone the Github repo and install the requirements:

`pip install -r requirements.txt`

Before submitting the PR, please ensure that:
 
- you run prospector for code analysis, and all checks are passing:

`prospector`

- all unit tests are passing:

`coverage run --branch --source='.' -m unittest`

- you have 100% unit test coverage:

`coverage report -m --fail-under=100 --omit=*/__init__.py,tests/*,setup.py`

## Links

* [PyPi](https://test.pypi.org/project/aws-lambda-decorators/)
* [Github](https://github.com/gridsmartercities/aws-lambda-decorators)

